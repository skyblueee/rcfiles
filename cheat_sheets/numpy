# __array_interface__
```python
In [287]: x = np.arange(10, dtype=np.uint8)
In [288]: x
Out[288]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=uint8)
In [289]: x.__array_interface__
Out[289]:
{'data': (155596184, False),
'descr': [('', '|u1')],
'shape': (10,),
'strides': None,
'typestr': '|u1',
'version': 3}
In [290]: x.data
Out[290]: <memory at 0xaec88f34>
In [291]: y=np.ndarray(shape=(3,), dtype=x.dtype, buffer=x.data, offset=3)
In [292]: y
Out[292]: array([3, 4, 5], dtype=uint8)
In [293]: y.__array_interface__
Out[293]:
{'data': (155596187, False),
'descr': [('', '|u1')],
'shape': (3,),
'strides': None,
'typestr': '|u1',
'version': 3}
In [294]: z=x[3:6]
In [295]: z
Out[295]: array([3, 4, 5], dtype=uint8)
In [296]: z.__array_interface__
Out[296]:
{'data': (155596187, False),
'descr': [('', '|u1')],
'shape': (3,),
'strides': None,
'typestr': '|u1',
'version': 3}
```
# ndarray的属性：
    1. ndim
    2. shape
    3. size
    4. dtype
    5. itemsize
    1. data -- 指向实际数据的指针
    6. nbytes
    7. T
    8. real
    9. imag
    10. flat
# 创建数组
    1. np.fill() 函数用于快速将数组中所有值赋值为一个标量。速度比array.flat=scalar快。
    2. 创建array()时指定初值list
    3. ones(), zeros(), eye()
# np.dtype是一个结构体类，常用于创建自定义的异构数据结构体。
# 修剪：clip()函数将数组中大于上限的值都赋值为上限，小于下限的值都赋值为下限。
# 筛选：compress()函数将数组中满足条件的部分筛选出来。
# 改变数组维数：
    1. ravel()
    2. flatten()
    3. 直接修改shape属性
# 拼接：np.stack(), np.concatenate()
# 拆分：np.split()
# 转换成list：ndarray.tolist()
# 数据类型转换：ndarray.astype()
# 文件读写
    1. CVS: loadtxt()，savetxt()
    2.
# 统计
    1. 加权平均：average()
    2. 极差（最大-最小）：ptp() -- peak to peak
    3. 中位数：median()
    4. 方差：var()
# 排序
    1. msort()
# 多项式
    1. 拟合：polyfit()
    2. 求值：polyval()
    3. 求根：roots()
    4. 求导：polyder()
# 卷积
    1. convolve()
# 避免循环
    1. 矢量化：np.vectorize(func)将作用于标量的函数进行矢量化，返回的函数可以作用于数组。
# 判断正负：sign()
# 判断两个array相等：np.array_equal(arrya1, array2)
# numpy to ctypes
> ctypes.
>       data
>       shape
>       strides
>       data_as()

## 基本
为了方便动态连接库的载入，numpy提供了一个便捷函数ctypeslib.load_library。它有两个参数，第一个参数是库的文件名，第二个参数是库所在的路径。函数返回的是一个ctypes的对象。通过此对象的属性可以直接到动态连接库所提供的函数。

例如，如果我们有一个库名为test_sum.dll，其中提供了一个函数mysum :

```C
double mysum(double a[], long n)
{
    double sum = 0;
    int i;
    for(i=0;i<n;i++) sum += a[i];
    return sum;
}
```

可以使用如下语句载入此库：

```python
>>> from ctypes import *
>>> sum_test = np.ctypeslib.load_library("sum_test", ".")
>>> print sum_test.mysum
<_FuncPtr object at 0x037D7210>
```

要正确调用sum函数，还必须对其参数类型进行说明，下面的语句描述了sum函数的两个参数的类型和返回值的类型进行描述：

```python
>>> sum_test.mysum.argtypes = [POINTER(c_double), c_long]
>>> sum_test.mysum.restype = c_double
```

接下来就可以正常调用sum函数了：

```python
>>> x = np.arange(1, 101, 1.0)
>>> sum_test.mysum(x.ctypes.data_as(POINTER(c_double)), len(x))
5050.0
```

每次调用sum都需要进行类型转换时比较麻烦的事情，因此可以编写一个Python的mysum函数，将C语言的mysum函数包装起来:

```python
def mysum(x):
    return sum_test.mysum(x.ctypes.data_as(POINTER(c_double)), len(x))
```

在上面的例子中，test_sum.mysum的参数值使用标准的ctypes类型声明：用POINTER(c_double)声明mysum函数的第一个参数是一个指向double的指针；然后调用数组x的x.ctypes.data_as函数将x转换为一个指向double的指针类型。

由于数组的元素在内存中的存储可以是不连续的，而且可以是多维数组，因此我们不能指望前面的mysum函数能够处理所有的情况：

```python
>>> x = np.arange(1,11,1.0)
>>>  mysum(x[::2])
15.0
>>> sum(x[::2])
25.0
```

由于x[::2]和x共同一块内存空间，而x[::2]中的元素是不连续的，每个元素之间的间隔为16byptes(2个double的大小)。因此将它传递给mysum的话，实际上计算的是x数组中前5项的和：1+2+3+4+5=15，而实际上我们希望的结果是：1+3+5+7+9=25。

为了对传递的数组参数进行更加详细的描述，numpy库提供了ndpointer函数。ndpointer函数对restype和argtypes中的数组参数进行描述，有4个参数：

- dtype : 数组的元素类型
- ndim : 数组的维数
- shape : 数组的形状，各个轴的长度
- flags : 数组的标志

例如：

```python
test_sum.mysum.argtypes = [
    np.ctypeslib.ndpointer(dtype=np.float64, ndim=1, flags="C_CONTIGUOUS"),
    c_long
]
```
描述了sumfunc函数的参数为一个元素类型为double的、一维的、连续的元素按C语言规定排列的数组。

这时传递给mysum函数的第一个参数可以直接是数组，因此无需再编写一个Python函数对其进行包装：

```python
>>> sum_test.mysum(x,len(x))
55.0
>>> sum_test.mysum(x[::2],len(x)/2)
ArgumentError: argument 1: <type 'exceptions.TypeError'>:
array must have flags ['C_CONTIGUOUS']
```

我们注意到如果参数数组不是连续空间的话，mysum函数的调用会抛出异常错误，提醒我们其参数需要C语言排列的连续数组。

如果我们希望它能够处理多维、不连续的数组的话，就需要把数组的shape和strides属性都传递给过去。假设我们想写一个通用的mysum2函数，它可以对二维数组的所有元素进行求和。下面是C语言的程序：

```C
double mysum2(double a[], int strides[], int shapes[])
{
    double sum = 0;
    int i, j, M, N, S0, S1;
    M = shape[0]; N=shape[1];
    S0 = strides[0] / sizeof(double);
    S1 = strides[1] / sizeof(double);

    for(i=0;i<M;i++){
        for(j=0;j<N;j++){
            sum += a[i*S0 + j*S1];
        }
    }
    return sum;
}
```

mysum2函数有3个参数，第一个参数a[]指向保存数组数据的内存块；第二个参数astrides指向保存数组各个轴元素之间的间隔(以byte为单位)；第三个参数dims指向保存数组各个轴长度的数组。

由于strides保存的是以byte为单位的间隔长度，因此需要除以sizeof(double)计算出以double为单位的间隔长度S0和S1。这样二维数组a中的第i行、第j列的元素可以通过a[i*S0 + j*S1]来存取。下面用ctypes对mysum2函数进行包装：

```python
sum_test.mysum2.restype = c_double
sum_test.mysum2.argtypes = [
    np.ctypeslib.ndpointer(dtype=np.float64, ndim=2),
    POINTER(c_int),
    POINTER(c_int)
]

def mysum2(x):
    return sum_test.mysum2(x, x.ctypes.strides, x.ctypes.shape)
```

注意不能直接传递x.strides和x.shape，因为这些是python的tuple对象，而x.ctypes.shape得到的是ctypes包装的整数数组：

```python
>>> x = np.zeros((3,4), np.float)
>>> x.ctypes.shape
<numpy.core._internal.c_long_Array_2 object at 0x020B4DF0>
>>> s = x.ctypes.shape
>>> s[0]
3
>>> s[1]
4
```
可以看出x.ctypes.shape是一个有两个元素的C语言长整型数组。虽然我们也可以在Python中通过下标读取其各个元素的值，但是通常它们是作为参数传递给C语言函数用的。
## 二维数组

双**是np.uintp类型的数组。因此，我们有
```python
xpp = (x.ctypes.data + np.arange(x.shape[0]) * x.strides[0]).astype(np.uintp)
_doublepp = np.ctypeslib.ndpointer(dtype=np.uintp)
```

```c
\#include <stdlib.h>

__declspec(dllexport) void foobar(const int m, const int n, const
double **x, double **y)
{
    size_t i, j;
    for(i=0; i<m; i++)
        for(j=0; j<n; j++)
            y[i][j] = x[i][j];
}
```

```python
import numpy as np
from numpy.ctypeslib import ndpointer
import ctypes

_doublepp = ndpointer(dtype=np.uintp, ndim=1, flags='C')

_dll = ctypes.CDLL('dummy.dll')

_foobar = _dll.foobar
_foobar.argtypes = [ctypes.c_int, ctypes.c_int, _doublepp, _doublepp]
_foobar.restype = None

def foobar(x):
    y = np.zeros_like(x)
    xpp = (x.__array_interface__['data'][0] + np.arange(x.shape[0]) * x.strides[0]).astype(np.uintp)
    ypp = (y.__array_interface__['data'][0] + np.arange(y.shape[0]) * y.strides[0]).astype(np.uintp)
    m = ctypes.c_int(x.shape[0])
    n = ctypes.c_int(x.shape[1])
    _foobar(m, n, xpp, ypp)
    return y

if __name__ == '__main__':
    x = np.arange(9.).reshape((3, 3))
    y = foobar(x)
```
# ctypes to numpy
## type(x) <class 'module_name.wrapper_class_name.c_double_Array_12000'>
```python
>>> np.ctypeslib.as_array(x)
```
## type(y) <class 'module_name.wrapper_class_name.LP_c_double'>
```python
buffer = numpy.core.multiarray.int_asbuffer(ctypes.addressof(y.contents), 8*array_length)
a = numpy.frombuffer(buffer, float)
```
```python
buffer_from_memory = ctypes.pythonapi.PyBuffer_FromMemory
buffer_from_memory.restype = ctypes.py_object

buffer = buffer_from_memory(y, 8*array_length)
a = numpy.frombuffer(buffer, float)
```
