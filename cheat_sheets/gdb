# Invoke GDB
* gdb [options] [program [core-file or process-id]]
* gdb [options] --args program [arguments ...]
* gdb -batch [-x cmdfile or -ex cmd]

# init file
1. /etc/gdb/gdbinit
2. ~/.gdbinit
3. -iex cmd -ix cmdfile
4. ./.gdbinit
5. -x cmdfile -ex cmd

# log
* set logging on/off
* show logging

# help
* help [command]
* apropos re-args : search through all the gdb commands, and their docs, for regular expression specified in args
* info/i : describe the state of your program.
* show : describe the state of gdb itself.
# basic
r, run                           # run the program
run > outfile                    # redirection
start                            # set tmp breakpoint at entrance and run
b[reak] some-method              # set a breakpoint
n[ext] [n]                       # step over
s[tep] [n]                       # step into
c[ontinue] [n]                   # continue
bt, backtrace                    # print stacktrace
p length=strlen(string)          # evaluate expressions and print
l, list                          # list surrounding source code
fin[ish]                         # run until current function resturns
return expression                # direct return from current function and use expression-value as return value
q, quit                          # exit

# fork and thread
set follow-fork-mode child/parent
set detach-on-fork on/off
info inferiors
inferior pid
detach inferiors        # quit debugging one of the forked processes, allow it to run independently
kill inferiors          #  quit debugging one of the forked processes, kill it
thread thread-id
info threads

# 設置環境變量
set env[ironment] LD_PRELOAD ./libc.so.6
unset env[ironment] VAR

# bookmark/checkpoint
* checkpoint        # Save a snapshot of current state.
* info checkpoints
* restart checkpoint-id
* delete checkpoint checkpoint-id

# *point
## breakpoint
* b[reak] location
* b ... if cond
* tbreak ...    # tmp breakpoint
* hbreak ...    # hardware breakpoint
* thbreak ...   # tmp hardware breakpoint
* rbreak regex  # breakpoints on all functions matching regex.
                # rbreak . : set breakpoints in all the functions
* rbreak file:regex # rbreak file.c:.
* info break[points] [list...]

## watchpoint - stop whenever the value of an expression changes
* watch [-l|-location] expr [thread thread-id] [mask maskvalue]
    * -l tells gdb to instead watch the memory referred to by expr.
    * watch *(int *)0x08195418
* rwatch ...    # break when the value of expr is read by the prog
* awatch ...    # break when the value of expr is read or write into
* info watchpoints [list...]

## catchpoint
* catch event
    * throw [regexp]
    * rethrow [regexp]
    * catch [regexp]
    * exception
    * handlers
    * exception unhandled
    * assert
    * exec
    * syscall [name | number | g[roup]:groupname] ...
    * fork
    * vfork
    * load [regexp]
    * unload [regexp]
    * signal [signal ...|'all']
* tcatch event      # tmp catchpoint
* use `info break` to list catchpoint

## clear/del/enable/disable breakpoint/watchpoint/catchpoint
* clear location
* d[elete] [*points] [list...]
* disable [*points] [list...]
* enable [*points] [once | count n] [list...]

## breakpoint command list
### 跟蹤heap動態變換
define mallocfinish
	finish
	printf "= %p\n", $eax
	continue
end

b malloc
commands 1
	silent
	printf "malloc(%d)        #", *(int*)($sp+4)
	mallocfinish
end

b free
commands 2
	silent
	printf "free(%p)\n", *(unsigned int*)($sp+4)
	c
end
## save break[points] [filename]

# print & printf
## p
* p[rint][/xduotacfszr]
* p *array@len  # int *array = (int *)malloc(len * sizeof(int))
* p (short[])0x12345678  # $2 = {0x1234, 0x5678}
* set print array-indexes on/off
* set $i = 0; p struct_array[$i++]->fv; RET; RET ...
* explore struct arg
## x: Examine memory
* x[/nfu] addr  # n: repeat count; f: display format;
                # u: unit size, bhwg
## display: prints value each time your program stops
* display [expr]
* display/pfmt expr
* display/xfmt addr
* undisplay dnums... | delete display dnums...
* enable|disable display dnums...
* info display
## printf
* printf template,expression[,expression...]
* dprintf location,template,expression[,expression...]
## pretty print: pretty-printing of values using Python code
info pretty-print [object-regexp [name-regexp]]

# until
u[ntil]             # when you reach the end of a loop after single stepping though it,
                    #   until makes your program continue execution until it exits the loop.
u[ntil] location    # continue until either location is reached or current stack frame returns.
                    #   The specified location is actually reached only if it is in the current frame.
                    #   This implies that until can be used to skip over recursive function invocations.
advance location    # similar to until, but advance will not skip over recursive function calls,
                    #   and the target location doesn’t have to be in the same frame as the current one.

# skip
Skip it even use step. Skips can be listed, deleted, disabled, and enabled, much like breakpoints.
* skip function [linespec]
* skip file [filename]

# value history
* $         # == $$0
* $$        # == $$1
* $$2       # == $$2
* p *$      # suppose you have just printed a pointer to a structure
            #   and want to see the contents of the structure.
* p *$.next # have a chain of structures whose next points to the next one,
            #   you can print the contents of the next one

# buildin(convenience) vars/funcs
* show convenience
* help function
    * $_memeq(buf1, buf2, length)

# registers
* $pc   # the program counter register ($eip, $rip)
* $sp   # the stack pointer ($esp, $rsp)
* $fp   # register contains pointer to current stack frame ($ebp, $rbp)
* $ps   # register contains the processor status (EFLAGS)

# search, dump and restore memory
* find [/[bhwg][n]] start_addr, +len, val1 [, val2, ...]
    * static char hello[] = "hello-hello";
    * (gdb) find &hello[0], +sizeof(hello), "hello"   # include trailing '\0'
            # 0x804956d <hello.1620+6>
            # 1 pattern found
    * (gdb) find &hello[0], +sizeof(hello), {char[5]}"hello"    # remove null terminator
            #0x8049567 <hello.1620>
            #0x804956d <hello.1620+6>
* find [/[bhwg][n]] start_addr, end_addr, val1 [, val2, ...]
* dump [format] memory filename start_addr end_addr
* dump [format] value filename expr
* append [binary] memory filename start_addr end_addr
* append [binary] value filename expr
* restore filename [binary] address [off_start off_end] # restore data.bin binary 0x7ffffff7fcf006

# change
* print x=1  # change var
* set var x=1  # change var
* set {int}0x83040 = 4  # change memory
* set $pc = 0x485  # change register
* restore memory

# User-defined cmd
* show user [cmdname]
* define cmdname
    define adder
        set $i = 0
        set $sum = 0
        while $i < $argc
            eval "set $sum = $sum + $arg%d", $i
            set $i = $i + 1
        end
        print $sum
    end
* user-defined cmd `hook-foo` runs before cmd `foo`
* user-defined cmd `hookpost-foo` runs after cmd `foo`
    define hook-echo
    echo <<<---
    end
    define hookpost-echo
    echo --->>>\n
    end
    (gdb) echo Hello World
    <<<---Hello World--->>>
* hook a multi-word command by adding hook- or hookpost- to the last word of the command, e.g. ‘define target hook-remote’ to add a hook to ‘target remote’.

# disable alarm
#
# more
* Specifying a Debugging Target # A target is the execution environment occupied by your program.
* Extending gdb using Python

